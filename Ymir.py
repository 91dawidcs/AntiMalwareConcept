## HeimdallBegin ##
import requests, os, json, time, sys

scriptName = os.path.basename(__file__)
scanTheFiles = True  # for scanning the files
fillTheList = True
fetchData = True
listOfFiles = []
Mimir = open("Mimir.txt", 'a')
PATH = os.environ['HOME'] + "/PycharmProjects/learningPython"

ApiKey = '<apikey>'

def countdown(t):
    while t:
        secs = t
        timeformat = '{:02d}'.format(secs)
        print("Time until the report request starts: " + timeformat, end='\r')
        time.sleep(1)
        t -= 1

def scan():
    while True:
        global fillTheList, scanTheFiles, ApiKey

        popTheLastElement = True
        # getting all the file and their path into the listOfFiles list
        if fillTheList:
            # getting all the file and their path into the listOfFiles list
            with os.scandir(os.getcwd()) as listOfDirs:
                for files in listOfDirs:
                    if not (str(files)[11:][:-2] == scriptName) and not (str(files)[11:][:-2] == "Mimir.txt") and not (
                            os.path.isdir(files)):
                        toScan = os.path.abspath(files)
                        listOfFiles.append(toScan)

        # try except, so if there is no element in the list it will turn scanTheFiles false, so the it won't request any new scans
        try:
            file = listOfFiles[listOfFiles.__len__() - 1]
        except IndexError:
            file = ""
            print("No more file to Scan")
            scanTheFiles = False
        else:
            scanTheFiles = True

        if scanTheFiles:
            try:
                url = 'https://www.virustotal.com/vtapi/v2/file/scan'  # connecting to the virustotal website
                params = {'apikey': ApiKey}  # apikey for requesting the scan
                files = {'file': (file, open(file, 'rb'))}  # file is opened and read to pass the data to the API
                responseScan = requests.post(url, files=files, params=params)  # sending the file and APIkey to do the scan
                responseJsonScan = responseScan.json()  # report from the scan module about the file

                resource = responseJsonScan["resource"]  # extracting the resource from the report, for later getting a verbose report
                open("Mimir.txt", 'a').write(resource + '\n')  # writing out the resource into a txt file

            except Exception as e:
                popTheLastElement = False
                print("Scan request failed /// Error: " + str(e))

            # popping the last element of the list, because the scan request is ended for this file
            try:
                if popTheLastElement:
                    listOfFiles.pop()
            except IndexError:
                fillTheList = True
            else:
                fillTheList = False

            print("Scanning has finished /file/: " + file)

        else:
            print("Scanning is done")
            fillTheList = True
            Mimir.close()
            break

        time.sleep(0.5)
        Mimir.close()  # closing the file

def report():
    while True:
        global fetchData

        removeElement = True

        if fetchData:
            with open("Mimir.txt", 'r') as MimirFile:
                fileContent = MimirFile.readlines()
                MimirFile.close()

        fetchData = False

        try:
            resourceReport = fileContent[0].rstrip()
        except IndexError:
            print("list is empty")
            askForReport = False
        else:
            askForReport = True

        if askForReport:
            try:
                url = 'https://www.virustotal.com/vtapi/v2/file/report'
                params = {'apikey': ApiKey, 'resource': resourceReport}
                responseReport = requests.get(url, params=params)
                responseJsonReport = responseReport.json()

                mainHashFile = PATH + "/hashMD52.txt"

                positives = int(responseJsonReport["positives"])

                if positives == 0:
                    open(mainHashFile, 'a').write(responseJsonReport["md5"] + '\n')
                elif positives > 0:
                    open(mainHashFile, 'a').write(responseJsonReport["md5"] + " HEL" + '\n')


            except Exception as e:
                print(responseJsonReport)
                print("Report request failed /// Error: " + str(e))
                removeElement = False



            if removeElement:
                print("File report received for resource number: " + resourceReport)
                fileContent.pop(0)
        else:
            deleteFileContent = open("Mimir.txt", 'r+')
            deleteFileContent.truncate(0)
            deleteFileContent.close()
            fetchData = True
            break

        time.sleep(15.3) # 15.3 because there can only be 4 requests every minute

while True:
    scan()
    countdown(45)
    report()

## HeimdallEnd ##

#-----------------------------------------------------------------------------------------------File Scanner On Computer
createLogFile = open("hashMD52.txt", 'a')
createLogFile.close()

## START ##
import time, sys, re, os, hashlib, subprocess, random, inspect
from shutil import copy
from multiprocessing import Process

PATH = os.environ['HOME'] + "/PycharmProjects/learningPython"
checker = None
checker = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
processes = []

def fileCopy(originalPlace, whereToCopy):
    import time
    # Copying the whole code from this file

    os.chdir(originalPlace)

    fileCode = []
    fileContent = open(sys.argv[0], "r")
    fileLines = fileContent.readlines()
    fileContent.close()
    insideFile = False

    for fileLine in fileLines:
        if (re.search('^## START ##', fileLine)): insideFile = True
        if (insideFile): fileCode.append(fileLine)
        if (re.search('^## END ##', fileLine)): break

    time = time.time()
    nameOfFile = "PHOENIX_" + str(time).split(".", 1)[1] + ".py"

    os.chdir(whereToCopy)

    newFile = open(nameOfFile, 'w')
    newFile.writelines(fileCode)
    newFile.close()
    print("Created Phoenix file: " + nameOfFile)

#is it executable function, returning bool
def isExecutable(file):

    isIt = False

    for index in file:
        intX = int(index)
        if intX == 5 or intX == 7:
            isIt = True

    return isIt

#lists the current directory names and returns a list of them
def listCurrentDirs():

    listOfDirs = []

    with os.scandir(checker) as ListOfFiles:
        for file in ListOfFiles:
            #list the directories, atm only test dirs
            if os.path.isdir(file) and "test" in str(file):
                listOfDirs.append(str(file))

    return listOfDirs

#Directory changer, only one layer down and creates the Phoenix file if there is not one//
# second check is to run the created Phoenix file without double running it
def subDirFileChecker():

    for dir in listCurrentDirs():
        PhoenixInSubDir = False
        dirChange = checker + "/" + dir[11:][:-2]
        os.chdir(dirChange)
        with os.scandir(os.getcwd()) as ListOfFilesSubDir:
            for fileSubDir in ListOfFilesSubDir:
                if "PHOENIX_" in str(fileSubDir) and not os.path.isdir(fileSubDir):
                    PhoenixInSubDir = True

        if not PhoenixInSubDir:
            fileCopy(checker, dirChange)

        with os.scandir(os.getcwd()) as ListOfFilesSubDir:
            for fileSubDir in ListOfFilesSubDir:
                if "PHOENIX_" in str(fileSubDir) and not os.path.isdir(fileSubDir):
                    runningFile = str(os.getcwd()) + "/" + str(fileSubDir)[11:][:-2]
                    processes.append(runningFile)


# Creating hashes and appending the md5 hash onto the main text file that contains all the hashes
def fileScanner(checker, counter):

    os.chdir(checker)
    with os.scandir(checker) as listOfFiles:
        for file in listOfFiles:

            if (os.path.isfile(file)):
                # returning for example 755 so rwxr-xr-x the file is 4 -r 2 - w 1 - x
                exeFile57 = isExecutable(str(oct(os.stat(file).st_mode)[-3:]))

                hasher = hashlib.md5()

                if exeFile57:
                    # opening the file and taking the whole content into the hasher and it spits out the md5
                    with open(file, 'rb') as open_file:
                        contentOfFile = open_file.read()
                        hasher.update(contentOfFile)

                        writeOut = str(hasher.hexdigest())
                        open_file.close()

                    hashOutPut = open(PATH + "/hashMD52.txt")
                    hashFilePath = PATH + "/hashMD52.txt"

                    md5Path = str(writeOut) + " " + str(os.getcwd()) + "/" + str(file)[11:][:-2]

                    srcPathBadFile = str(os.getcwd()) + "/" + str(file)[11:][:-2]
                    destPathBadFile = PATH + "/badFiles"

                    if counter == 0:
                        if not (str(md5Path)) in hashOutPut.read():
                            open(hashFilePath, 'a').write(writeOut + '\n')
                            hashOutPut.close()
                        else:
                            print("Already Scanned: " + md5Path)
                            hashOutPut.close()

                    #after the first run, it will copy every new file into the bad file folder
                    elif not (str(md5Path)) in hashOutPut.read():
                        copy(srcPathBadFile, destPathBadFile)
                        print("Suspicious file copied: " + srcPathBadFile)
                        open(hashFilePath, 'a').write(md5Path + '\n')
                        print("File MD5 is added to the database")
                        hashOutPut.close()

    print(str(counter)+ "   " + sys.argv[0])
        #KILLSWITCH FOR ALL THE SCRIPTS IF TEXT FILE CONTAINS !!!!!STOP!!!!!
    if "!!!!!STOP!!!!!" in open(PATH + "/hashMD52.txt").read():
        sys.exit("ProgramStopped -- return 0 // " + sys.argv[0]) #RUNNING THE SCRIPTS IN CHAIN SO THEY HAVE A RETURN
#*************************************************************NEED TO FIX IT TO MAKE THE CHAIN RUN!!!!!!! *****************************************************
    time.sleep(random.randint(25,35))

def loopScanner():
    counter = 0
    while True:
        fileScanner(checker, counter)
        counter += 1

def runFile(s):
    subprocess.call('python3 ' + s, shell=True)

#===================================================================================

if __name__ == '__main__':

    subDirFileChecker()

    for p in processes:
        task = Process(target=runFile, args=(p,))
        task.start()
        print("-----------------------" + sys.argv[0] + "  <<<<<<< This file runs this >>>>>>  " + p)
        time.sleep(1.5)

    loopScanner()

## END ##

